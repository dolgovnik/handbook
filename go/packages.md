[[../index.md|<-- Go Back]]

# = Packages =
__Пакеты__ (__П__) позволяют структурировать проект, чтобы __Ф__ можно было располагать вместе, но без необходимости держать все в одном файле

__П__ - это отдельное пространство имен для своих объявлений.

__П__ управляет _инкапсуляцией_, определяя какие имена выдны снаружи, а какие - нет

`go mod init <package_name>` создает файл модуля (`go.mod`), он упрощает установку опубликованных __П__, позволяет использовать `go run .` - все само компилируется.

```
############
###go.mod###
############

module packages  // <-- имя модуля, в данном случае packages. Оно нужно для импорта Ф из других
                 // пакетов, созданных в рамках одного проекта.

go 1.22.4        // <-- версия Go
```

Добавление __П__ в структуру проекта:
```
######################
###store/product.go###
######################

package store        // <-- определение пользовательского пакета store
                     // имя должно совпадать с именем папки в котором он лежит

type Product struct {   // <-- Можно экспортировать
	Name string         // <-- Можно экспортировать
	Category string     // <-- Можно экспортировать
	price float64       // <-- Нельзя экспортировать
}
```

Использование пользовательского пакета:
```
#############
###main.go###
#############

package main

import (
    "fmt"
	"packages/store"    // <-- <имя модуля>/<имя пакета> - это путь импорта
)

func main(){
	product := store.Product {    // <-- доступ к экспортируемым функциям через имя пакета
		Name: "Kayak",
		Category: "Watersports",
    }
	fmt.Println(product.Name)
}
```

Можно делать вложенные пакеты
```
import (
    "fmt"
	"packages/store/cart"
)

c := cart.Cart {...
...
}
```

## == Управление доступом к пакетам ==
Если первая буква строчная, то функция может использоваться только в пакете, в котором она определена.
Если первая буква ЗАГЛАВНАЯ, то функцию можно экспортировать.
Это относится ко всем именам - __типов__, __С__, __Ф__, __полей__
Это НЕ относится к именам параметров __Ф__

## == Добавление файлов кода в пакеты ==
Управление доступа и префиксы __П__ не применяются для сущеностей из одного __П__

Пример:
```
#############
###main.go###
#############

package main

import (
    "fmt"
	"packages/store"
)

func main(){
	product := store.NewProduct("Kayak", "Watersports", 275.00) // <-- Создаем новую структуру 
	                                                            // с помощью конструктора
	fmt.Println("Name:", product.Name)
	fmt.Println("Category:", product.Category)
	fmt.Println("Price:", product.Price())     // <-- получаем доступ к НЕ экспортируемому calcTax
	                                           // через экспортируемый метод Price
}

######################
###store/product.go###
######################

package store

var standardTax = newTaxRate(0.25, 20)  // <-- внутри пакета store работают НЕ экспортируемые Ф
                                        // обращаемся к ним без имени П
type Product struct {
	Name string
	Category string
	price float64
}

func NewProduct (name string, category string, price float64) *Product {
	return &Product{name, category, price}
}

func (p *Product) Price() float64 {
	return standardTax.calcTax(p)  // <-- теже комментарии что и выше
}

func (p *Product) SetPrice(price float64) {
	p.price = price
}

##################
###store/tax.go###
##################

package store

const defaultTaxRate float64 = 0.2
const minThreshold = 10

type taxRate struct {
	rate float64
	threshold float64
}

func newTaxRate(rate float64, threshold float64) *taxRate {  // <-- НЕ экспортируется
	if (rate ==0){
		rate = defaultTaxRate
	}
	if (threshold < minThreshold) {
		threshold = minThreshold
	}
	return &taxRate{rate, threshold}
}

func (tr *taxRate) calcTax(product *Product) float64 {   // <-- НЕ экспортируется,
                                                         // работает только внутри store
    if (product.price > tr.threshold){                   // <-- получает доступ к полю price типа
	                                                     // Product и делает это без использования
														 // имени пакета
		return product.price + (product.price * tr.rate)
	}
	return product.price
}
```

Результат выполнения:
```
Name: Kayak
Category: Watersports
Price: 343.75
```

## == Импорт ==
__!!!__ Конфликты имен можно разрешить так:
```
import (
    newPackegeName "module_name/package_name"
)
```

__!!!__ Точечный импрорт позволяет использовать __Ф__ без использования префикса
```
import (
    . "packages/fmt"
)
```

## == Инициализация пакета == 
Инициализация пакета начинается с инициализации _переменных уровня пакета_, в том порядке в котором они объявлены, __НО__ сначала разрешаются зависимости:
```
var a = b + c    // инициализируется третьей, значение высчитывается
var b = f()      // инициализируется второй, значенем которое возвращает Ф f
var c = 1        // инициализируется первой, значение 1
```
Если пакет состоит из нескольких файлов, то они нициализируются в том порядке, к каком файлы передаются компилятору, по умолчанию сортировка по имени

Инициализация выполняется _снизу вверх_, т.е. импортирующий пакет точно уверен что все импорты и инициализации импортируемого пакета уже выполнены. Последним инициализируется пакет `main` 

## == Функция инициализации пакета ==
__Ф__ __инициализации__ вызывается автоматически при загрузке пакета (после загрузки всех пакетов и выполнения их инициализации)
Пример:
```
func init() {     // <-- Название init, параметров запуска нет
    for c, p := range categoryMaxPrices {
	.
	.
	.
	}
}
```

`init` - не обыкновенная __Ф__, ее нельзя вызвать напрямую, зато в одном файле можно определить несколько таких __Ф__

__Ф инициализации__ должны быть независимы друг от друга, так как порядок их выполнения не гарантируется.

__!!!__ Можно использовать пустой идентификатор если нужна инициализация, а остальные __Ф__ не нужны:
```
import (
    _ "packages/store"
)
```

# = Внешние пакеты =
__П__ загружаются и устанавливаются с помощью команды `go get`:
```
go get github.com/fatih/color@v1.10.0
```
грузит пакет нужной версии с гитхаба, компилирует его и устанавливает чтобы можно было использовать в проекте
Также новый пакет будет отображен в файле `go.mod`
В `go.sum` будут отображаться контрольные суммы

Дальше надо импортировать модуль:
```
import (
    "github.com/fatih/color"
)

color.Green("blah-blah")
```

Внешние __П__ вытягивают зависимости, импользуется наибольшая версия из всех доступных

Если пакет больше не нужен, то он НЕ удалится автоматически, для этого используется команда `go mod tidy`

# = Senssitivee shit =
__!!!__ чтобы экспортировать __Ф__ надо чтобы для нее был описан комментарий. Также можно описвать поля и пакеты. Комментарии обрабатываюся инструментом `go doc`

__!!!__ компилятор не различает имена присвоенные __переменным__ и имена присвоенные __типам__ поэтому имена должны быть уникальными

