[[../index.md|<--Go Back]]

# = Types Operations =

## == Go Operators  ==
`+, -, *, /, %` - арифметические операции - применяются к числовым типам, a __%__ (остаток от деления) только к целым числам. Значения должны быть одного типа
`==, !=, <, <=, >, >=` - сравнения
`=, :=` - присваивание
`-=, +=, ++, --` - увеличение, уменьшение числовых значений
`&, |, ^, &^, <<, >>` - побитовые операции
`||, &&, !` - логические операторы

### === Переполнение ===
```
package main

import (
		"fmt"
		"math"
)

func main() {
    var intVal = math.MaxInt64
	var floatVal = math.MaxFloat64

	fmt.Println(intVal * 2)
	fmt.Println(floatVal * 2)

	fmt.Println(math.IsInf((floatVal * 2), 0))
}
```
Результат выполнения:
`-2` - целочисленное значение __переносится__
`+Inf` - значение с плавающей точкой __переполняется__
`true` - бесконечность обнаружена

### === Объединение строк ===
`+` - объединяет строки, НО не объединяет строки с другими типами (для этого есть стандартная библиотека)

### === Сравнение ===
__!!!__ Значения должны быть одного типа или нетипизированными константами, которые могут быть представлены в целевой тип
__!!!__ __Точнее__ первый операнд должен быть присваемым __типу__ второго операнда и наоборот

__!!!__ Можно сравнивать указатели чтобы понять указывают ли они на одну и ту же ячейку - сравниваются области памяти, а не значения которые в них хранятся

### === Логические операторы ===
__!!!__ С логическими опрераторами можно использовать только логические значения - Go не будет преобразовывать другие значения
__!!!__ Для получения результата оценивается наименьшее кол-во значений

## == Преобразование значений ==
Так нельзя - разные типы!
```
a := 30
b := 40.5
t := a + b
```
Можно вот так:
```
a := 30
b := 40.5
t := float64(a) + b
```

Ситаксис явных преобразований - `T(x)` - где `T` - это целевой тип, а `x` - это значение которое надо преобразовать. Так работают только явные преобразования - только когда значение может быть представлено в целевом типе (числа в числа, строки в руны). Такой подход может уменьшить точность значений или вызвать переполнение.

Для преобразования значений с плавающей точков в целые имеется несколько функций: `Ceil`, `Floor`, `Round`, `RoundToEven`

__!!!__ Преобразование одного __типа__ в другой разрешено, если оба они имеют один и тот же _базовый тип_ или если оба они являются неименованными указателями на переменные одного и того же _базового типа_ - такие преобразования изменяют __тип__, но не изменяют значения
Пример - __тип__ `Cilsius ` можно преобразовать в __тип__ `Fahrenheit `, так как у них один _базовый тип_ `float64`:
```
type Cilsius float64
type Fahrenheit float64
```

## ==  Парсинг из строк ==
`strconv` - пакет для парсинга строк в другие типы, в нем есть набор методов для парсинга

!!! при парсинге цифр указывается размер в который должно поместиться число, но результат будет всегда иметь тип int64
!!! можно указать основание числа или 0 для определения основания по префиксу строки
!!! `strconv.Atoi` - преобразует из строки в десятичное число за один шаг
!!! `ParseFloat` - парсит цифры с плавающей точкой и с экспонентой

## ==  Преобразование в строки ===
`strconv` - умеет преобразовывать разные типы в строки

- `FormatBool`
- `FormatInt` и `FormatUint` - для целых чисел, принимают число и основание.
- `Itoa` - для упрощения преобразования целых десятичных чисел в строки: принимает __int__, преобразует его в __int64__ и передает его в __ParseInt__ (????)
- `FormatFloat` - можно гибко форматировать числа с плавающей запятой, превращая их в строки

## == Sensetive shit ==
!!! Оператор `+` можно использовать для конкатенации строк
