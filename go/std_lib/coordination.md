[[index.md|<-- Go back]]

# = Группы ожидания =
`sync.WaitGroup` - __С__ которую можно использовать для ожидания завкршения одной или нескольких __ГР__
__!!!__ `WaitGroup` - это счетчик. Если значение станет отрицательным, то будет вызвана __паника__
__!!!__ Важно чтобы общее кол-во значений переданных методу `Add` было равно кол-во вызовов `Done()`: если `Done()` мало - тогда что то будет вечно заблокированным, если много - тогда __паника__
__!!!__ Важно добавлять и убавлять значение у __одной и той же__ `WaitGroup`

Прмер:
```
################
###printer.go###
################

package main

import "fmt"

func Printfln(template string, vals ...interface{}) {
	fmt.Printf(template + "\n", vals...)
}

#############
###main.go###
#############

package main

import (
	"sync"
)

var waitGroup = sync.WaitGroup{} // <-- Создаем WaitGroup

func doSum(count int, val *int) {
	for i := 1; i <= count; i++ {
		*val++
	}
	waitGroup.Done()            // <-- Когда ГР заканчивает работу, уменьшаем кол-во ГР,
	                            // окончания которых мы ожидаем
}

func main() {
	var t int = 0
	waitGroup.Add(1)           // <-- Добавляем кол-во ГР окончания которых мы ждем
	                           // в данном случае у на с всего одна ГР
	go doSum(5000, &t)
	waitGroup.Wait()           // <-- Блокируем main до тех пор пока не будет выполнен Done
	                           // т.е. пока WaitGroup останется пустой
	Printfln("Value: %v", t)
}
```
Результат выполнения
```
Value: 5000
```

# = Mutex =
__Mutex__ (Mutual Exclusion) - обеспечивает взаимное исключение одновременного выполнения _критических участков кода_
В __Go__ для этого применяется структура `sync.Mutex`
Пример:
```
################
###printer.go###
################

package main

import "fmt"

func Printfln(template string, vals ...interface{}) {
	fmt.Printf(template + "\n", vals...)
}

#############
###main.go###
#############

package main

import (
	"sync"
)

var waitGroup = sync.WaitGroup{} //<-- Создаем WaitGroup, чтобы дождаться выполнения всех ГР
var mutex = sync.Mutex{} //<-- Создаем Мьютекс, чтобы обезопасить изменение одной переменной
                         // разными ГР

func doSum(count int, val *int) {
	for i := 1; i <= count; i++ {
		mutex.Lock()     //<-- Лочим Мьютекс перед изменение значения переменной
		                 //таким образом, другие ГР не смогут залочить этот Мьютекс и,
						 // соответственно, изменить переменную одновременно с другой ГР
		*val++
		mutex.Unlock()   //<-- Разлочиваем, после того как значенеи изменено
	}
	waitGroup.Done()
}

func main() {
	var t int = 0
	var grNum = 3
	waitGroup.Add(grNum)          //<-- Наполняем WG, чтобы дождаться выполнения всех ГР
	for i := 0; i < grNum; i++ {  //<-- Запускаем несколько ГР, которые изменяют одну и ту же
	                              // переменную. Так как используем Mutex, то ГР не конфиликтуют
								  // при изменении, а координируются через Mutex
		go doSum(5000, &t)
	}
	waitGroup.Wait()              //<-- Ждем выполнения всех ГР
	Printfln("Value: %v", t)
}
```
Результат выполнения
```
Value: 15000
```

# = RWMutex =
`RWMutex` позволяет делать два вида блокировок:
- для чтения `RLock()` -- `RUnlock()`
- для записи `Lock()` -- `Unlock()`

Принцип работы:
- Если `RWMutex` разблокирован, то блокировку может получить `RLock` или `Lock` 
- Если блокировку получил `RLock`, то другой `RLock` тоже может ее получить, а `Lock` НЕ сможет до тех пор пока все _читатели_ не выполнят `RUnlock`
- Если блокировку получил `Lock`, то ни `RLock` ни другой `Lock` не смогут получить блокировку до тех пор пока не будет вызван метод `Unlock`
- Если блокировку получил `RLock`, и вызывается `Lock` тогда оба медода	`Lock` и `RLock` будут блокироваться до тех пор пока не будет вызван `Unlock` - это сделано чтобы _читатели_ полностью не заблокировали `RWMutex`

# = Условия =
TODO

# = Однократное выполнение функции =
TODO

# = Контекст =
Пакет `context` предоставляет __тип__ `Context`, который упрощает управление запросами в клиент-серверных приложениях


