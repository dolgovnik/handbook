[[../index.md|<--Go Back]]

# = Constants Vars and Pointers =

## == Constants ==

Константа - это имя для определенного значения, применяется для удобства использования
Значение константы известно компилятору, его вычисление происходит во время компиляции.
__!!!__ Базовый тип константы это обязательно логическое значение, строка или число

* __Типизированные__
        `const price float32 = 275.0`

* __Нетипизированные__ - говорим компилятору, что он должен быть более гибким (и вероятно более точным в случае цифр) в отношении типа при создании константы - компилятор преобразует значение если это можно. Такие констаны не принадлежат какому то определенному типу, поэтому могут использоваться более гибко и хранить более точное значение.
        `const quantity = 2`
  __Литеральные значения__ - это __нетипизированные константы__. Компилятор видя литеральное значение определяет его тип и использует дальше.

При создании констант удобно пользоваться генератором `iota`
Пример:
```
type Weekday int
const (
	Sunday Weekday = iota // 0
	Monday                // 1
	Tuesday               // 2
	Wednesday
	Thrusday
	Friday
	Saturday
)
```

## == Vars ==

`var` создает переменную _определенного_ __типа__, назначает ей __имя__ и присваивает __начальное значение__
Не бывает __неинициализированных переменных__

Пример:
<ключевое слово> <имя> <тип> = <значение>
`var price float32 = 275.0`

- __Тип__ можно пропустить, тогда компилятор выведет тип из переданного значения
- __Значение__ можно пропустить, но тогда должен быть указан тип. В этом случае, переменной присваивается нулевое значение для указанного типа.
Можно определить несколько переменных с помощью одного оператора __var__

Все приведенные ниже варианты дают один результат:
```
s := ""             // <-- самый краткий вариант
var s string        // <-- это инициализация по умолчанию
var s = ""          // <-- используется редко, в основном при объявлении нескольких переменных
var s string = ""   // <-- лишнее указание типа
```

Эти вариаты используются когда:
- когда требуется явно указать тип
- когда значение переменной будет присвоенно позже

__Переменные__ _уровня пакета_ инициализируются до начала выполнения __Ф__ `main`. _Время жизни_ такой переменной равно времени работы всей программы
_Локальные_ __переменные__ инициализируются тогда, когда в проуцессе выполнения __Ф__ встречаются их объявления. Переменная _живет_ до тех пор, пока она _доступна_ - после этого выделенная для нее память может быть использована повторно. _Параметры_ и _результаты_ __Ф__ - это локальные __переменные__, они создаються при вызове __Ф__


### === Vars Short Syntax ===

!!! __Можно использовать только внутри функций__
Пример:
```
price := 275.00
price, tax, inStock := 275.00, 27.50, true
```

Компилятор выводит типы из переданных значений

!!! __Позволяет переопределять переменные__
Так нельзя:
```
var a, b = 12, 33
var a, c = 45, 55
```

А так можно - важно, чтобы хотя бы одна переменная не существовала и чтобы тип не изменялся.
```
var a, b := 12, 33
var a, c := 45, 55 //<-- переменная `a` не не определяется, а ПРИСВАИВАЕТСЯ
```

### === Empty Vars ===
Нельзя создать переменную и не использовать ее - компилятор будет ругаться.
Для таких ситуаций можно использовать пустой идентификатор - `'_'`
Пустой идентификатор пригодится, если надо проигнорировать часть значений которые возвращает функция

Пример:
```
package main

import "fmt"

func main(){
    price, _ = 275.00, false
	var _ = "Alice"
	fmt.Println("Price:", price)
}
```

### === Присваивание ===
__Присваивание__ происходит не только _явно_ (=), но и _неявно_.
Примеры _неявного_ присваения:
- значение аргументов соответствующим переменным
- `return` присвает значение результирующей переменной
- литеральный синтаксис среза присваивает значени элементам по индексам

Главное чтобы __типы__ слева и справа совпадали
Значение `nil` может быть присвоенно любой пременной _интерфейсного или ссылочного_ __типа__

## == Pointers ==
Каждая __переменная__ - это ссылка на отдельную ячейку памяти, в которой хранится ее значение

__Указатель__ - это __переменная__, значением которой является адрес в памяти, по которому хранится значение с определенным типом.
```
package main

import "fmt"

func main(){
    first := 100
	var second *int = &first //<-- `&` - это оператор адреса
	
	first++
	
	fmt.Println("First:", first)
	fmt.Println("Second:", second)
}
```
Результат выполнения:
`First: 101`
`Second: 0xc000124010`  - значение переменной `second` - это адрес в памяти, который используется для хранения переменной `first`

`*int` - это __тип указателя__, он основан на __типе переменной__ из которой он создан. 
Т.е. `second` - это __переменная__, значением которой является __адрес в памяти__ по которому хранится значение типа __int__

__Следование указателю__ - чтение значения по адресу памяти, на который указывает указатель - это делается с помощью символа `*`
```
package main

import "fmt"

func main(){
    first := 100
	var second *int = &first
	
	first++
	
	fmt.Println("First:", first)
	fmt.Println("Second:", *second)    // <-- следование указателю
}
```
Результат выполнения:
`First: 101`
`Second: 101` - следуем указателю, т.е. читаем значение в ячейке с адресом, который хранится в second. В этой ячейке хранится значение `first = 101`

Указатель можно присвоить другой переменной:

`var myNewPointer *int` - новая переменная с типом `*int` - указатель указывающий на int
`myNewPointer  = second` - присвоеное значения
`*myNewPointer++` - следование указателю, изменение значения в ячейке

### === Нулевое значение указателя ===
Указатель, который определен, но не имеет _нормального_ значения, по умолчанию имеет _нулевое_ значение __nil__
```
package main

import "fmt"

func main() {
    first := 100
	var second *int
	
	fmt.Println(second)
	second = &first
	fmt.Println(second)
}
```
Результат выполнения:
```
<nil>
0xc000010088
```

!!! Следование нулевому указателю завершится ошибкой - __runtime error__

### === Указатели на указатели ===
Указатели могут хранить адреса, по которым хранятся другие указатели
```
package main

import "fmt"

func main() {
    first := 100
	second := &first
	third := &second
	
	fmt.Println(first)
	fmt.Println(*second)
	fmt.Println(**third)
}
```
Результат выполнения:
```
100
100
100
```

### === Сравнение указателей ===
Два __указателя__ равны тогда и только тогда, когда они указывают на одну и туже переменную или когда они оба равны `nil`

__!!!__ в некоторых случаях переменные, которые не несут никакой информации (`struct{}`, `[0]int`)могут иметь один и тот же адрес => указатели на них будут равны.

### === Функция new ===
__Ф__ `new` создает неименованную переменную указаннаго типа, инициализирует ее _нулевым_ значением указанного типа, и возврадает __указатель__ на нее.
Пример:
```
p := new(int) //<-- переменная `p` будет иметь тип *int
fmt.Println(*p) //<-- выведет 0
*p = 2
fmt.Println(*p) //<-- выведет 2
```

### === Польза указателей ===
!!! Указатели позволяют выбирать между передачей значения и передачей ссылки

## == Область видимости ==
__Область видимости__ (__ОВ__) - часть исходного кода, в которой использование объявленного имени ссылается на _сущность_ из этого объявления.
__ОВ__ - это свойство _времени компиляции_ - это то что находится между _фигурных скобок_ или в _лексическом блоке_, т.е. внутри блока кода.

Если _сущность_ объявлена ВНУТРИ __функции__, то она будет локальной для данной __функции__ и не будет видна больше нигда.
Если _сущность_ объявлена ВНЕ __функции__, то она видна во всех файлах пакета к которому она принадлежит.

Переменные ищутся начиная с самой глубокой области видимости

__!!!__ __Время жизни__ переменной - диапазон времени выполнения, когда к переменной можно обращаться из других частей программы - это свойство _времени выполнения_

## == Garbage Collector (Сборщик мусора) ==
__Garbage Collector__ - __GC__
Очень грубо говоря, __GC__ смотрит сколько ссылок есть на __переменную__ и если _нет ни одной_, тогда уничтожает переменную
Пример #1:
```
var global *int
func f() {
	var x int
	x = 1        //<-- `x` остается доступной через `global` после возврата из `f`
	global = &x
}
```
Пример #2:
```
func g() {
	y := new(int) //<-- `y` становится недоступной после возврата из `g`
	*y = 1
}
```

__!!!__ Таким образом, не надо сохранять ссылки на короткоживущие объекты внутри долгоживущих - это приводит к большему потреблению памяти

## == Sensetive shit ==
- Отсутствие типа для переменных обрабатывается не так как для констант. Для переменных не позволяется смешивать типы, даже если их можно преобразовать.
- Go не поддерживает арифметику указателей

