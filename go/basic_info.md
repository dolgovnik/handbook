[[../index.md|<--Go Back]]

# = Go: Basic Information =

## == Create and Run Go application ==

1. Для старта проекта необходимо создать файл _go.mod_, который используется для отслеживания пакетов от которых зависит проект.
   Данный файл используется для публикации проекта
		
        go mod init <project_name>
   команда создает файл go.mod TODO Зачем он нужен??

2. Запуcк и компиляция выполняются командой
 
        go run .

## == Using command go ==

* go __build__ - компилирует исходный код, создает исполняемый файл
* go __clean__ - удаляет результаты выполнения команды __go build__
* go __doc__ - создает документацию из исходного кода
* go __fmt__ - добавляет отступы в файл кода, чтобы всё было ровненько
* go __get__ - загружает и устанавливает внешние пакеты
* go __install__ - загружает пакеты, _непонятно чем отличается от get_
* go __help__ - спрвка по другим командам go, например _go help build_
* go __mod__ - создание модуля Go и управление им
* go __run__ - компилирует и выполняет исходные код, исполняемый файл хранится во временной папке
* go __test__ - выполняет модульные тест
* go __version__ - номер версии
* go __vet__ - линтер

## == General knovelege ==

__Пакет__ (__package__) - группа связанных функций. Каждый файл кода должен объявлять пакет к которому принадлежит
    `package main`

__Оператор импорта__ (__import__) - объявляет зависимости от других пакетов. Результат выполнения - ссылка на пакет, далее можно вызывать функции из этого пакета. Если импортируется __math/rand__, то ссылка будет __rand__
    `import "fmt"`
	
__Функция__ (__func__) - блок операторов, которые выполняются при вызове функции. Функция __main__ - это точка входа, с нее начинается выполнение при вызове скомпелированного кода
```	
    func main() {
	    fmt.Println("Hello, Go")
	}
```
	
## == Sensetive shit ==	

* Неочевидная фигня с `";"`:  Компилятор сам добавляет `;` там где это надо в коде. Т.е. можно их не писать. Но если код отформатирован не верно, то будут появляться странные ошибки о проблемах с `;`
* Функции Go часто возвращают два значения: результат выполнения функции и ошибку, которая могла произойти при выполнении функции. Ошибку можно обработать в вызывающем коде.
