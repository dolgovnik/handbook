[[collections.md|<--Go Back]]

# = Двойная природа строк =

__Строки__ - это массив __байт__ `byte`
__Строки__ поддерживают нотацию индекса `[1]` и диапазона среза `[2:10]`.
`byte` - это псевдоним `uint8` 
```
price := "$49.95"
```
| $          | 4         | 8    | .    | 9    | 5    |
| ---------- | -----     | ---- | ---- | ---- | ---- |
| 36         | 52        | 56   | 46   | 57   | 53   |
| price[0]   | price[1:]                             |

При разделении строки - получается другая строка
Для интерпретации `byte` как символа - требуется явное преобразование
```
string(price[0])
```
__!!!__ но это работает, только если символ занимает один __байт__

Для решения этой проблемы можно использовать тип `rune` - это одна кодовая точка __Unicode__
```
var price []rune = []rune("€48.95")
```
Теперь это __срез рун__ и его можно нарезать на отдельные __руны__, которые выражают отдельные символы
__!!!__ `rune` это псевдоним для `int32`, поэтому при печати `rune` их надо перобразовывать в `string`

__Байты__ важны когда мы говорим о хранении __строк__
__Символы__ важны когда мы говорим о содержимом __строк__

# = Перечисление строк =
Используем цикл `for` - эта фукнция в том числе отображает __байты__ в __руны__
```
package main

import (
    "fmt"
	//"strconv"
)

func main() {

    var price = "€48.95"

	for i, c := range price {
	    fmt.Println(i, c, string(c))
	}
}
```
Результат выполнения:
```
0 8364 €
3 52 4
4 56 8
5 46 .
6 57 9
7 53 5
```
__!!!__ Т.е. __Go__ обрабатывает строки как последовательность __рун__
__!!!__ __Внимание!!__ значения индексов непоследовательные - так как Go обрабатывает __строку__ как последовательность __символов__ полученную из последовательности __байтов__
Значение индекса соответствует первому байту символа

Если надо получить __байты__, тогда необходимо преобразовать строку в __срез байтов__ - тогда индексы будут последовательными
```
for i, c := range []byte(price){
   ....
}
```
