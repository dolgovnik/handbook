[[collections.md|<--Go Back]]

# = General =
__Строка__ - _неизменяемая_ последовательность байтов, обычно они содержат текст.
`len` - возвращает кол-во __байтов__ (а не символов!) в строке
`s[i]` - __индексирование__ возвращает __i-й байт__ строки `s`: i-й __байт__ это не обязательно i-й __символ__

Так как строки неизменяемые, то они могут безопасно разделять одну и ту же память - например строка и ее подстроки.

_Строковые литералы_ заключаются в двойные кавычки `""`, escape - `\`
_Неформатированный строковый литерал_ записывается в обратных кавычках  - внутри него escape не обрабатывается - удобно для `regexp`


В __Go__ по умолчанию используется __UTF-8__

# = Двойная природа строк =

__Строки__ - это массив __байт__ `byte`
__Строки__ поддерживают нотацию индекса `[1]` и диапазона среза `[2:10]`.
`byte` - это псевдоним `uint8` 
```
price := "$49.95"
```
| $          | 4         | 8    | .    | 9    | 5    |
| ---------- | --------- | ---- | ---- | ---- | ---- |
| 36         | 52        | 56   | 46   | 57   | 53   |
| price[0]   | price[1:] |      |      |      |      |

При разделении строки - получается другая строка
Для интерпретации `byte` как символа - требуется явное преобразование
```
string(price[0])
```
__!!!__ но это работает, только если символ занимает один __байт__

Для решения этой проблемы можно использовать тип `rune` - это одна кодовая точка __Unicode__
```
var price []rune = []rune("€48.95")
```
Теперь это __срез рун__ и его можно нарезать на отдельные __руны__, которые выражают отдельные символы
__!!!__ `rune` это псевдоним для `int32`, поэтому при печати `rune` их надо перобразовывать в `string`

__Байты__ важны когда мы говорим о хранении __строк__
__Символы__ важны когда мы говорим о содержимом __строк__

# = Перечисление строк =
Используем цикл `for` - эта фукнция в том числе отображает __байты__ в __руны__
```
package main

import "fmt"

func main() {

    var price = "€48.95"

	for i, c := range price {
	    fmt.Println(i, c, string(c))
	}
}
```
Результат выполнения:
```
0 8364 €
3 52 4     // <-- смотри какой индекс!
4 56 8
5 46 .
6 57 9
7 53 5
```
__!!!__ Т.е. __Go__ обрабатывает строки как последовательность __рун__
__!!!__ __Внимание!!__ значения индексов непоследовательные - так как Go обрабатывает __строку__ как последовательность __символов__ полученную из последовательности __байтов__
Значение индекса соответствует первому байту символа

Если надо получить __байты__, тогда необходимо преобразовать строку в __срез байтов__ - тогда индексы будут последовательными
```
for i, c := range []byte(price){
   ....
}
```
# = UTF-8 =
__UTF-8__ - кодировка переменной длинны символов __Unicode__ в виде байтов
