[[collections.md|<--Go Back]]

# = Array =
Пример:
```
package main

import "fmt"

func main() {
	var names [3]string

	names[0] = "Kayak"
	names[1] = "Lifejacket"
	names[2] = "Paddle"

	fmt.Println(names)
}
```
Результат выполнения:
```
[Kayak Lifejacket Paddle]
```

__Массив__ - это последовательность фиксированной длинны из нуля или более элементов(в данном случае `[3]`) одного __типа__ (в данном случае - `string` - базовый тип). Доступ к элементам осуществляется по индексу
__!!!__ Размер __массива__ должен быть константным выражением, т.е. его значение можно вычислить во время компиляции программы.
__!!!__ После создания, массив заполняется нуливыми значениями типа элемента: для строки - это пустая строка `""`

Литеральный синтаксис:
```
names := [3]string {"Kayak", "Lifejacket", "Paddle"}
```

Многомерный массив:
```
var coords [3][3]int
```


## == Тип массива ==
__Тип массива__ - это комбинация его размера и базового типа
```
names := [3]string {"Kayak", "Lifejacket", "Paddle"}
```

Тип переменной `names` - `[3]string` , т.е. массив с базовым типом `string` и емкостью `3`. Поэтому вот такое не будет работать (так как типы разные) и не важно что в новом массиве хватает места:
```
names := [3]string {"Kayak", "Lifejacket", "Paddle"}
var otherArray [4]string = names
```
^ Так не будет работать.

Компилятор может сам определить длинну массива:
```
names := [...]string {"Kayak", "Lifejacket", "Paddle"}
```

Можно сделать так:
```
type Currency int

const (
	USD Currency = iota
	EUR
	GBP
	RUR
)

symbol := [...]string{USD: "$", EUR: "€", GBP: "£", RUR: "₽"}
```

## == Значения массива ==
__Go__ по умолчанию работает с __значениями__, а не со __ссылками__ - такое поведение распространяется и на массивы

Значения:
```
names := [3]string {"Kayak", "Lifejacket", "Paddle"}
var otherArray := names
```

Ссылки (__указатели__):
```
names := [3]string {"Kayak", "Lifejacket", "Paddle"}
var otherArray := &names
```
В этом случае тип переменной otherArray - `*[3]string` - указатель на массив, способный хранить три строковых значения.

__!!!__ Массив может содержать указатели - это значит, что значения массива НЕ копируются, при копировании массива.

## == Сравнение массивов ==
Массивы равны если они одного типа и содержат одинаковые элементы в одном и том же порядке
__???__ как это работает с указателями?

Пример:
```
a := [2]int{1, 2}
b := [...]int{1, 2}
c := [2]{1, 3}
d := [3]{1, 2}

fmt.Println(a == b) //<-- true
fmt.Println(a == c) //<-- false
fmt.Println(b == c) //<-- false
fmt.Println(a == d) //<-- Ошибка компиляции, так как у a и d разные типы.
```

## == Перечисление массивов ==
Надо использовать `for` и `range`
За подробностями смотри [[../flowcontrol.md### === Перечисление последовательностей ===|FlowControl]]

# == Sensetive shit ==
