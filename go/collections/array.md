[[collections.md|<--Go Back]]

# = Array =
Пример:
```
package main

import "fmt"

func main() {
	var names [3]string

	names[0] = "Kayak"
	names[1] = "Lifejacket"
	names[2] = "Paddle"

	fmt.Println(names)
}
```
Результат выполнения:
```
[Kayak Lifejacket Paddle]
```

__Массив__ - фиксированная длинна (`[3]`), все элементы имеют один тип (`string` - базовый тип). Доступ к элементам осуществляется по индексу
__!!!__ После создания, массив заполняется нуливыми значениями типа элемента: для строки - это пустая строка `""`

Литеральный синтаксис:
```
names := [3]string {"Kayak", "Lifejacket", "Paddle"}
```

Многомерный массив:
```
var coords [3][3]int
```


## == Тип массива ==
__Тип массива__ - это комбинация его размера и базового типа
```
names := [3]string {"Kayak", "Lifejacket", "Paddle"}
```

Тип переменной `names` - `[3]string` , т.е. массив с базовым типом `string` и емкостью `3`. Поэтому вот такое не будет работать (так как типы разные) и не важно что в новом массиве хватает места:
```
names := [3]string {"Kayak", "Lifejacket", "Paddle"}
var otherArray [4]string = names
```
^ Так не будет работать.

Компилятор может сам определить длинну массива:
```
names := [...]string {"Kayak", "Lifejacket", "Paddle"}
```

## == Значения массива ==
__Go__ по умолчанию работает с __значениями__, а не со __ссылками__ - такое поведение распространяется и на массивы

Значения:
```
names := [3]string {"Kayak", "Lifejacket", "Paddle"}
var otherArray := names
```

Ссылки:
```
names := [3]string {"Kayak", "Lifejacket", "Paddle"}
var otherArray := &names
```
В этом случае тип переменной otherArray - `*[3]string` - указатель на массив, способный хранить три строковых значения.

__!!!__ Массив может содержать указатели - это значит, что значения массива НЕ копируются, при копировании массива.

## == Сравнение массивов ==
Массивы равны если они одного типа и содержат одинаковые элементы в одном и том же порядке
__???__ как это работает с указателями?

## == Перечисление массивов ==
Надо использовать `for` и `range`
За подробностями смотри [[../flowcontrol.md### === Перечисление последовательностей ===|FlowControl]]

# == Sensetive shit ==
