[[index.md|<--Go Back]]

# = Interfaces =
__Интерфейс__ (__И__) - описывает набор __М__ без указания их реализации - т.е. набор _сигнатур_. Если __тип__ реализует все методы, определенные интерфейсом, то значение этого __типа__ можно использовать везде где разрешен данный __И__
__И__ позволяют писать более гибкие __Ф__, которые не привязаны к деталям конкретной реализации
__Интерфейсы__ нужны только в том случае, если есть несколько конкретных типов, работа с которыми должна вы­полняться единообразно. Исключение - интерфейс для развязывания типа и его использования в разных пакетах
Пример:
```
################
###product.go###
################

package main

type Product struct {
	name string
	category string
	price float64
}

func (p Product) getName() string {        // <-- реализация интерфейса
	return p.name
}

func (p Product) getCost(_ bool) float64 { // <-- реализация интерфейса
	return p.price
}

################
###service.go###
################
 
package main

type Service struct {
	description string
	durationMonths int
	monthlyFee float64
}

func (s Service) getName() string {              // <-- реализация интерфейса
	return s.description
}

func (s Service) getCost(recur bool) float64 {   // <-- реализация интерфейса
	if (recur) {
		return s.monthlyFee * float64(s.durationMonths)
	}
	return s.monthlyFee
}

#############
###main.go###
#############

package main

import "fmt"

type Expense interface {           // <-- Определение интерфейса
	getName() string               // <-- сигнатура метода: имя,типы параметров и возвращаемого результата
	getCost(annual bool) float64   // <-- сигнатура метода
}

func main() {
	expenses := []Expense{
	    Product{"Kayak", "Watersports", 275.50},
	    Service{"Boat Cover", 12, 89.0},
	}

	for _, e := range expenses {
		fmt.Println("Name:", e.getName(), "Coast:", e.getCost(true))
	}
}
```
Результат выполнения:
```
Name: Kayak Coast: 275.5
Name: Boat Cover Coast: 1068
```

__!!!__ Порядок __методов__ не имеет значения
__!!!__ Все __методы__ перечисленные в __И__ должны быть определены.
__!!!__ _Имена параметров_ могут быть разные. Должны совпадать _имена методов_, _типы параметров_ и _типы результатов_

После того как __И__ реализован (т.е созданы все методы, имена и типы совпадают), можно ссылаться на значение через __тип интерфейса__. В примере выше мы ссылаемся на значение `Product` и `Service` через интерфейс `Expense`

Можно передавать __тип И__ в качестве параметра __Ф__:
```
func calcTotal(expenses []Expense) (total float64) {
    for _, item := range expenses {
	    total += item.getCost(true)
	}
	return
}
```

Можно использовать __тип И__ в качестве поля __С__:
```
type Account struct {
    accountNum int
	expenses []Expense
}
```

## == Динамический и Статический тип ==
__Тип__ __интерфейса__ - это _абстрактный_ тип, он не раскрывает структуру или внутреннюю реализацию своих значений - а показывает только не которые __методы__
Переменная, __тип__ которой является __И__ имеют два типа
* _статический_ - Интерфейсный тип, в примере `Expense` - он никогда не меняется
* _динамический_ - тип значения, в примере `Product` и `Service` - может измениться если будет присвоенно значение другого типа реализующего данный __И__
__И__ позволяют использовать различные _динамические типы_ в одном месте через реализацию _статического_ интерфейса

__!!!__ Цикл `for` имеет дело только со _статическим типом_.

## == Значения интерфейсов ==
Пример:
```
var w io.Writer
w = os.Stdout
w = new(bytes.Buffer)
w = nil
```
Разберем пример построчно:
### === Строка 1 ===
```
var w io.Writer
```
_Нулевое_ значение для __И__ имеет:
__Тип__ == `nil`
__Значение__ == `nil` (описывается на основе __динамического типа__)
Можно выполнить сравнение: `w == nil` или `w != nil`
Вызов любого метода _нулевого_ интерфейса приведет к аварии
```
w.Write([]bytes("hello")) //<-- Авария, указатель нулевой
```
### === Строка 2 ===
```
w = os.Stdout
```
Присваеваем `w` значение `*os.File` - тут происходит _неявное_ преобразование из _конкретного_ типа в тип _интерфейса_, эквивалентное _явному_ преобразованию `io.Writer(os.Stdout)` - происходит пребразование и ипа и значения.
__Динамический тип__ устанавливается равным _дескриптору_ для типа указателя `*os.File`, а __динамическое__ значение хранит копию `os.Stdout`, которая является указателем на переменную `os.File`
```
w.Write([]bytes("hello")) //<-- hello
```

Во время компиляции, мы не можем знать какой будет __динамический тип__ - поэтому вызов метода должен использовать _динамическую диспетчеризацию_: компилятор генерирует код для получения адреса с именем `Write` из дескриптора типа и выполнить косвенный вызов по этому адресу. Аргумент для вызова - копия динамического значения интерфейса `os.Stdout`. Результат будет такой же как если бы мы вызвали:
```
os.Stdout.Write([]byte("hello"))
```
### === Строка 3 ===
```
w = new(bytes.Buffer)
```
Теперь __динамический тип__ представляет собой `*bytes.Buffer`, а __динамическое значение__ - указатель на вновь созданный буфер.
```
w.Write([]bytes("hello")) //<-- hello в bytes.Buffer
```
### === Строка 4 ===
```
w = nil
```
Оба компонента сбрасываться в `nil`, получается то же состояние, которые было при объявлении `w`

## == Приемники, методы, указатели ==
__!!!!!!!!__ __ОЧЕНЬ ВАЖНЫЙ МОМЕНТ__
Пример __#1__:
```
product := Product {"Kayak", "Watersports", 275.0}
var expense Expense = product      // <-- Значение product КОПИРУЕТСЯ
product.price = 100
fmt.Println(product.price)        // <-- 100
fmt.Println(expense.getCost())    // <-- 275
```
Значение `product` скопировалось, поэтому изменение его полей не влияют на значение полей `expense`
Пример __#2__:
```
product := Product {"Kayak", "Watersports", 275.0}
var expense Expense = &product      // <-- используем УКАЗАТЕЛЬ, значение НЕ КОПИРУЕТСЯ
product.price = 100
fmt.Println(product.price)        // <-- 100
fmt.Println(expense.getCost())    // <-- 100
```
Ссылка на `Product` присваеваеся переменной `Expense`, но это __НЕ МЕНЯЕТ тип переменной И__ (`expense`), он по прежнему является `Expense`. Выглядит _не логично_ так как переменная всегда `Expense`, а значение может быть либо `Product` либо `*Product`
__!!!__ Т.е. можно выбирать как будет использоваться значение присвоенное переменной __И__

Пример __#3__:
```
func (p *Product) getName() string {   // <-- Приемник - тип указателя!
    return p.name
}

func (p *Product) getCost(_ bool) float64 {
    return p.price
}
```
__!!!__ Теперь `Product` НЕ реализует __И__ `Expense`, так как необходимые __М__ НЕ определены для __С__ `Product`. __И__ `Expense` реализуется __типом__ `*Prodiuct` - т.е. __указатели__ на значение `Product` можно рассматривать как занчения `Expense`. Следовательно код ниже работать НЕ будет:
```
product := Product {"Kayak", "Watersports", 275.0}
var expense Expense = product             // Product не реализует интерфейс (тип) Expense
```
Смотри причины такого поведения в разделе [[methods.md|Методы]]

## == Сравнение значений интерфейса ==
Два значения __И__ равны если: они имеют одинаковый __динамический тип__ и все их поля равны или если они оба равны `nil`

__!!!__ Надо быть осторожным с __указателями__: если __динамический тип__ будет __типом указателя__, тогда сравнение может быть неудачным, так как __указатели__ равны только тогда, когда они указывают в одно и тоже место в памяти.

__!!!__ Могут быть проблемы если __динамический тип__ не сопоставим, например если в __С__ есть __срез__ или другой _несравнимый_ __тип__. Поэтому могут возникнуть проблемы если использовать __И__ как _ключи_ в __отображениях__, или как _операнды_ в `switch`


__!!!__ Нулевое значение __И__, которое не содержин значения как такового, не совпадает со значением __И__, которое содержит нулевой указатель.

## == Утверждения (декларация) типа ==
Часто надо иметь возможность из __И__ получить доступ к __динамическому типу__. Это называется - __сужение типа__: процесс перехода от _менее_ точного __типа__ к _более_ точному.

### === Вариант 1 ===
__Утверждение типа__ используется для доступа к _динамическому_ __типу__ значения __И__:
```
x.(T) //<-- x-интерфейсный тип, T-декларируемый КОНКРЕТНЫЙ ТИП
```
Результат успешной проверки - динамическое значение `x` типом которого является `T`.
Если проверка неудачна, то авария

Пример:
```
package main

import "fmt"

type Expense interface {
	getName() string
	getCost(annual bool) float64
}

func main() {
	expenses := []Expense{
	    Service{"Boat Cover", 12, 89.0},
	    Service{"Paddle Protect", 6, 7.5},
		&Product{"Kayak", "Watersports", 275.0},
	}

	for _, e := range expenses {
		if s, ok := e.(Service); ok {  // <-- Утверждение типа, далее можно использовать
		                               // любые поля из типа Service, а не только методы
									   // определенные в интерфейсе Expense
									   // если ok == false, то s == нулевому значению
									   // Service
	   	    fmt.Println("Service:", s.description)
        } else {
	   	    fmt.Println("Expense:", e.getName())
		}
	}
}
```
Результат выполнения:
```
Service: Boat Cover
Service: Paddle Protect
Expense: Kayak
```
### === Вариант 2 ===
```
x.(T) //<-- x-интерфейсный тип, T-декларируемый ТИП ИНТЕРФЕЙСА
```
В этом случае, декларация проверяет, соответствует ли динамический тип `x` интерфесу `T`Проверка успешна - значение не извлекается, значением результата остается значение интерфейса с теми же типами, но сам результат имеет тип `T` - становится доступно больше методов.
Пример:
```
var w io.Writer
w = os.Stdout
rw := w.(io.ReadWriter) //<-- SUCCESS, *os.File имеет методы Read и Write
w = new(ByteCounter)
rw = w.(io.ReadWriter) //<-- Error, *ByteCounter не имеет метода Read
```

__!!!__ НЕ ПУТАТЬ __утверждение типа__ и __переобразование типа__:
    1) __утверждение__ применяется только к __И__ - сообщает компилятору, что значение __И__ имеет определенный __динамический тип__
    2) __преобразование__ применяется к определенным __типам__, а не к __И__, только в том случае если структура этих __типов__ совместима

## == Switch ==
Можно использовать оператор `switch`
```
for _, expense := range expenses {
    switch value := expense.(type){   // <-- специальный тип утверждения
	    case Service:
		    fmt.Println("Service")
		case *Product: 
		    fmt.Println("*Product")
		default:
		    fmt.Println("Something")
	}
}
```
__!!!__ внутри оператора `case` работает __утверждение__, поэтому там можно использовать ВСЕ поля и методы __типа__.

## == Пустой интерфейс ==
_Пустой_ __И__ - это __И__, который не имеет __М__, он может представлять ЛЮБОЙ __тип__. Удобно для группировки __типов__, которые не имеют ничего общего между собой.
Пример:
```
data := []interface{}{    // <-- срез пустых интерфейсов
    "This is a string",
	100,
	true
}
```
Дальше можно обрабатывать такой __срез__ с помощью `switch`

Можно использовать так:
```
func processItem(item interface{}){
    switch val := item.(type) {
	    case Product:
		.
		.
		.
	}
}
```

Можно использовать для переменных параметров - позволяет вызывать __Ф__ с любым кол-вом аргументовлюбого типа:
```
func processItem(items ...interface{}){
    for _, item := range items {
	    switch value := item.(type){
		    case Product:
			.
			.
			.
		}
	}
}
```

# = Sensitive shit =
__!!!__ Можно сделать вот так:
```
Product.printDetails(Product{"Kayak, "Watersports", 275})
```
Или так:
```
(*Product).printDetails(&Product{"Kayak, "Watersports", 275})
```
В этих случаях тип __приемника__ должен совпадать, т.е. не будет работать автоматическое определение __указателя__ или __значения__
